{
    "sourceFile": "src/routes/orderRoutes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1741462273941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741463348720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -150,16 +150,8 @@\n       { orderStatus: status },\n       { new: true }\n     );\n \n-    // Add after status update:\n-    const notification = new Notification({\n-      recipient: order.author,\n-      message: `Order status updated to ${status}`,\n-      type: 'order'\n-    });\n-    await notification.save();\n-\n     res.json({\n       message: 'Order status updated',\n       order\n     });\n"
                },
                {
                    "date": 1741465828881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,16 @@\n     if (quantity <= 0 || !Number.isInteger(quantity)) {\n       return res.status(400).json({ message: 'Invalid quantity' });\n     }\n \n-    const totalCost = book.authorCopyPrice * quantity;\n+    // Add author copy price check\n+    const isAuthorCopy = book.authorId.equals(req.user._id);\n+    const unitPrice = isAuthorCopy && book.authorCopyPrice > 0 \n+      ? book.authorCopyPrice \n+      : book.price;\n \n+    const totalCost = unitPrice * quantity;\n+\n     if (paymentMethod === 'wallet') {\n       const author = await User.findById(req.user._id);\n       if (author.walletBalance < totalCost) {\n         return res.status(400).json({ message: 'Insufficient wallet balance' });\n@@ -46,9 +52,10 @@\n       author: req.user._id,\n       quantity,\n       totalCost,\n       paymentMethod,\n-      paymentStatus: paymentMethod === 'wallet' ? 'Paid' : 'Pending'\n+      paymentStatus: paymentMethod === 'wallet' ? 'Paid' : 'Pending',\n+      isAuthorCopy\n     };\n \n     if (paymentMethod === 'razorpay') {\n       const razorpayOrder = await razorpay.orders.create({\n"
                }
            ],
            "date": 1741462273941,
            "name": "Commit-0",
            "content": "const express = require('express');\nconst router = express.Router();\nconst { auth, authorizeRole } = require('../middleware/auth');\nconst Order = require('../models/Order');\nconst Book = require('../models/Book');\nconst User = require('../models/User');\nconst Notification = require('../models/Notification');\nconst Razorpay = require('razorpay');\nconst crypto = require('crypto');\n\nconst razorpay = new Razorpay({\n  key_id: process.env.RAZORPAY_KEY_ID,\n  key_secret: process.env.RAZORPAY_KEY_SECRET\n});\n\n// Create order with payment options\nrouter.post('/', auth, async (req, res) => {\n  try {\n    const { bookId, quantity, paymentMethod } = req.body;\n    const book = await Book.findById(bookId);\n    \n    // Add validation checks\n    if (!book) {\n      return res.status(404).json({ message: 'Book not found' });\n    }\n    if (typeof book.authorCopyPrice !== 'number' || book.authorCopyPrice <= 0) {\n      return res.status(400).json({ message: 'Invalid book pricing configuration' });\n    }\n    if (quantity <= 0 || !Number.isInteger(quantity)) {\n      return res.status(400).json({ message: 'Invalid quantity' });\n    }\n\n    const totalCost = book.authorCopyPrice * quantity;\n\n    if (paymentMethod === 'wallet') {\n      const author = await User.findById(req.user._id);\n      if (author.walletBalance < totalCost) {\n        return res.status(400).json({ message: 'Insufficient wallet balance' });\n      }\n      author.walletBalance -= totalCost;\n      await author.save();\n    }\n\n    const orderData = {\n      book: bookId,\n      author: req.user._id,\n      quantity,\n      totalCost,\n      paymentMethod,\n      paymentStatus: paymentMethod === 'wallet' ? 'Paid' : 'Pending'\n    };\n\n    if (paymentMethod === 'razorpay') {\n      const razorpayOrder = await razorpay.orders.create({\n        amount: totalCost * 100, // in paise\n        currency: \"INR\",\n        receipt: `order_${Date.now()}`\n      });\n\n      orderData.razorpayOrderId = razorpayOrder.id;\n      orderData.paymentStatus = 'Processing';\n    }\n\n    const order = new Order(orderData);\n    await order.save();\n\n    res.status(201).json({\n      message: paymentMethod === 'wallet' ? 'Order placed successfully' : 'Payment initiated',\n      order,\n      razorpayOrder: paymentMethod === 'razorpay' ? razorpayOrder : null\n    });\n\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error creating order',\n      error: error.message \n    });\n  }\n});\n\n// Razorpay Webhook\nrouter.post('/razorpay-webhook', async (req, res) => {\n  const shasum = crypto.createHmac('sha256', process.env.RAZORPAY_WEBHOOK_SECRET);\n  shasum.update(JSON.stringify(req.body));\n  const digest = shasum.digest('hex');\n\n  if (digest !== req.headers['x-razorpay-signature']) {\n    return res.status(400).json({ message: 'Invalid signature' });\n  }\n\n  const { payload } = req.body;\n  const order = await Order.findOne({ razorpayOrderId: payload.payment.entity.order_id });\n\n  if (payload.event === 'payment.captured') {\n    order.paymentStatus = 'Paid';\n    order.razorpayPaymentId = payload.payment.entity.id;\n    order.razorpaySignature = digest;\n    await order.save();\n    \n    // Notify admin\n    const notification = new Notification({\n      recipient: 'admin',\n      message: `New order payment received for ${order.quantity} copies`,\n      type: 'order',\n      metadata: { orderId: order._id }\n    });\n    await notification.save();\n  }\n\n  res.json({ status: 'ok' });\n});\n\n// Get author's orders\nrouter.get('/my-orders', auth, async (req, res) => {\n  try {\n    const orders = await Order.find({ author: req.user._id })\n      .populate('book', 'title coverImage');\n      \n    res.json(orders);\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error fetching orders',\n      error: error.message \n    });\n  }\n});\n\n// Admin get all orders\nrouter.get('/admin', auth, authorizeRole(['admin']), async (req, res) => {\n  try {\n    const orders = await Order.find()\n      .populate('book', 'title')\n      .populate('author', 'name email');\n      \n    res.json(orders);\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error fetching orders',\n      error: error.message \n    });\n  }\n});\n\n// Update order status (Admin)\nrouter.put('/:id/status', auth, authorizeRole(['admin']), async (req, res) => {\n  try {\n    const { status } = req.body;\n    const order = await Order.findByIdAndUpdate(\n      req.params.id,\n      { orderStatus: status },\n      { new: true }\n    );\n\n    // Add after status update:\n    const notification = new Notification({\n      recipient: order.author,\n      message: `Order status updated to ${status}`,\n      type: 'order'\n    });\n    await notification.save();\n\n    res.json({\n      message: 'Order status updated',\n      order\n    });\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error updating order',\n      error: error.message \n    });\n  }\n});\n\nmodule.exports = router; "
        }
    ]
}
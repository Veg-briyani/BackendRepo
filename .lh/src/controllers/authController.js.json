{
    "sourceFile": "src/controllers/authController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1741454159899,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741454178706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,30 +198,20 @@\n };\n \n const updateProfile = async (req, res) => {\n   try {\n-    let updates = req.body;\n+    const updates = req.body;\n     \n-    // Handle file upload\n-    if (req.file) {\n-      updates.profilePhoto = `${process.env.BASE_URL}/profile-photos/${req.file.filename}`;\n-    }\n-\n-    // Update allowed updates\n+    // Only allow certain fields to be updated\n     const allowedUpdates = [\n       'name', 'phoneNumber', 'address', 'bankAccount', \n-      'about', 'profilePhoto', 'governmentId', 'authorStats'\n+      'about', 'profilePhoto', 'governmentId'\n     ];\n     \n     const filteredUpdates = Object.keys(updates)\n       .filter(key => allowedUpdates.includes(key))\n       .reduce((obj, key) => {\n-        // Handle nested objects\n-        if (key === 'authorStats') {\n-          obj[key] = updates[key];\n-        } else {\n-          obj[key] = updates[key];\n-        }\n+        obj[key] = updates[key];\n         return obj;\n       }, {});\n \n     // If KYC details are updated, reset status to pending\n"
                },
                {
                    "date": 1741454201307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,9 +203,9 @@\n     \n     // Only allow certain fields to be updated\n     const allowedUpdates = [\n       'name', 'phoneNumber', 'address', 'bankAccount', \n-      'about', 'profilePhoto', 'governmentId'\n+      'about', 'profilePhoto', 'governmentId', 'authorStats'\n     ];\n     \n     const filteredUpdates = Object.keys(updates)\n       .filter(key => allowedUpdates.includes(key))\n"
                },
                {
                    "date": 1741462273862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,8 +90,11 @@\n       subject: emailTemplate.subject,\n       html: emailTemplate.html\n     });\n \n+    // Update last login timestamp\n+    await User.findByIdAndUpdate(user._id, { lastLogin: new Date() });\n+\n     // Return user data without password\n     const userData = user.toObject();\n     delete userData.password;\n \n"
                },
                {
                    "date": 1741463348653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,364 @@\n+const jwt = require('jsonwebtoken');\n+const User = require('../models/User');\n+const { \n+  sendEmail, \n+  getWelcomeEmailTemplate, \n+  getLoginNotificationTemplate,\n+  getPasswordResetTemplate \n+} = require('../config/email');\n+const { OAuth2Client } = require('google-auth-library');\n+const Royalty = require('../models/Royalty');\n+const { sendSMS } = require('../services/notificationService');\n+\n+const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);\n+\n+const generateToken = (userId) => {\n+  return jwt.sign({ userId }, process.env.JWT_SECRET, {\n+    expiresIn: process.env.JWT_EXPIRES_IN || '30d'\n+  });\n+};\n+\n+const register = async (req, res) => {\n+  try {\n+    const { email, name } = req.body;\n+    \n+    // Check if user already exists\n+    const existingUser = await User.findOne({ email });\n+    if (existingUser) {\n+      return res.status(400).json({ message: 'User already exists' });\n+    }\n+\n+    // Create new user\n+    const user = new User(req.body);\n+    await user.save();\n+\n+    // Generate token\n+    const token = generateToken(user._id);\n+\n+    // Send welcome email\n+    const emailTemplate = getWelcomeEmailTemplate(name);\n+    await sendEmail({\n+      to: email,\n+      subject: emailTemplate.subject,\n+      html: emailTemplate.html\n+    });\n+\n+    // Send SMS notification\n+    await sendSMS(user.phone, `Welcome ${user.name}! Your author account is ready.`);\n+\n+    // Return user data without password\n+    const userData = user.toObject();\n+    delete userData.password;\n+\n+    res.status(201).json({\n+      message: 'User registered successfully',\n+      user: userData,\n+      token\n+    });\n+  } catch (error) {\n+    res.status(500).json({ \n+      message: 'Error registering user',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+const login = async (req, res) => {\n+  try {\n+    const { email, password } = req.body;\n+    \n+    // Find user by email\n+    const user = await User.findOne({ email }).select('+password');\n+\n+    if (!user) {\n+      return res.status(401).json({ message: 'Invalid credentials' });\n+    }\n+\n+    // Check password\n+    const isMatch = await user.comparePassword(password);\n+    if (!isMatch) {\n+      return res.status(401).json({ message: 'Invalid credentials' });\n+    }\n+\n+    // Generate token\n+    const token = generateToken(user._id);\n+\n+    // Send login notification email\n+    const emailTemplate = getLoginNotificationTemplate(user.name);\n+    await sendEmail({\n+      to: email,\n+      subject: emailTemplate.subject,\n+      html: emailTemplate.html\n+    });\n+\n+    // Return user data without password\n+    const userData = user.toObject();\n+    delete userData.password;\n+\n+    res.json({\n+      message: 'Login successful',\n+      user: userData,\n+      token\n+    });\n+  } catch (error) {\n+    res.status(500).json({ \n+      message: 'Error logging in',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+const forgotPassword = async (req, res) => {\n+  try {\n+    const { email } = req.body;\n+\n+    // Find user\n+    const user = await User.findOne({ email });\n+    if (!user) {\n+      return res.status(404).json({ message: 'User not found' });\n+    }\n+\n+    // Generate password reset token\n+    const resetToken = jwt.sign(\n+      { userId: user._id },\n+      process.env.JWT_SECRET,\n+      { expiresIn: '1h' }\n+    );\n+\n+    // Create password reset link\n+    const resetLink = `${process.env.CLIENT_URL}/reset-password?token=${resetToken}`;\n+\n+    // Send password reset email\n+    const emailTemplate = getPasswordResetTemplate(user.name, resetLink);\n+    await sendEmail({\n+      to: email,\n+      subject: emailTemplate.subject,\n+      html: emailTemplate.html\n+    });\n+\n+    res.json({ \n+      message: 'Password reset instructions sent to your email' \n+    });\n+  } catch (error) {\n+    res.status(500).json({ \n+      message: 'Error processing forgot password request',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+const resetPassword = async (req, res) => {\n+  try {\n+    const { token, newPassword } = req.body;\n+    \n+    // Verify token and decode payload\n+    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n+    \n+    // Find user by decoded ID\n+    const user = await User.findById(decoded.userId);\n+    if (!user) {\n+      return res.status(404).json({ message: 'User not found' });\n+    }\n+\n+    // Update password and save\n+    user.password = newPassword;\n+    await user.save();\n+    \n+    res.json({ message: 'Password reset successful' });\n+  } catch (error) {\n+    // Handle specific JWT errors\n+    if (error instanceof jwt.JsonWebTokenError || error instanceof jwt.TokenExpiredError) {\n+      return res.status(401).json({ \n+        message: 'Invalid or expired token',\n+        error: error.message \n+      });\n+    }\n+    \n+    // Handle other errors\n+    res.status(500).json({ \n+      message: 'Error resetting password',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+const getProfile = async (req, res) => {\n+  try {\n+    const user = await User.findById(req.user._id).select('-password');\n+    if (!user) {\n+      return res.status(404).json({ message: 'User not found' });\n+    }\n+    res.json(user);\n+  } catch (error) {\n+    res.status(500).json({ \n+      message: 'Error fetching profile',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+const updateProfile = async (req, res) => {\n+  try {\n+    const updates = req.body;\n+    \n+    // Only allow certain fields to be updated\n+    const allowedUpdates = [\n+      'name', 'phoneNumber', 'address', 'bankAccount', \n+      'about', 'profilePhoto', 'governmentId', 'authorStats'\n+    ];\n+    \n+    const filteredUpdates = Object.keys(updates)\n+      .filter(key => allowedUpdates.includes(key))\n+      .reduce((obj, key) => {\n+        obj[key] = updates[key];\n+        return obj;\n+      }, {});\n+\n+    // If KYC details are updated, reset status to pending\n+    if (filteredUpdates.governmentId || filteredUpdates.bankAccount) {\n+      filteredUpdates.kycStatus = 'pending';\n+    }\n+\n+    const user = await User.findByIdAndUpdate(\n+      req.user._id,\n+      { $set: filteredUpdates },\n+      { new: true, runValidators: true }\n+    ).select('-password -governmentId');\n+\n+    res.json({\n+      message: 'Profile updated successfully',\n+      user\n+    });\n+  } catch (error) {\n+    res.status(500).json({ \n+      message: 'Error updating profile',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+const googleLogin = async (req, res) => {\n+  try {\n+    const { token } = req.body;\n+    \n+    // Verify Google token\n+    const ticket = await client.verifyIdToken({\n+      idToken: token,\n+      audience: process.env.GOOGLE_CLIENT_ID\n+    });\n+    \n+    const payload = ticket.getPayload();\n+    \n+    // Check if user already exists\n+    let user = await User.findOne({ \n+      $or: [{ googleId: payload.sub }, { email: payload.email }]\n+    });\n+\n+    if (!user) {\n+      // Create new user\n+      user = new User({\n+        name: payload.name,\n+        email: payload.email,\n+        googleId: payload.sub,\n+        authMethod: 'google',\n+        verified: true,\n+        profile: {\n+          photo: payload.picture\n+        }\n+      });\n+      await user.save();\n+    }\n+\n+    // Generate JWT\n+    const jwtToken = generateToken(user._id);\n+    \n+    // Return user data\n+    const userData = user.toObject();\n+    delete userData.password;\n+\n+    res.json({\n+      message: 'Google login successful',\n+      user: userData,\n+      token: jwtToken\n+    });\n+\n+  } catch (error) {\n+    res.status(401).json({\n+      message: 'Google authentication failed',\n+      error: error.message\n+    });\n+  }\n+};\n+\n+const requestPayout = async (req, res) => {\n+  try {\n+    const { amount, paymentMethod } = req.body;\n+    \n+    // Check available royalty balance\n+    const author = await User.findById(req.user._id);\n+    if (author.outstandingRoyalty < amount) {\n+      return res.status(400).json({ \n+        message: 'Insufficient royalty balance' \n+      });\n+    }\n+\n+    // Create payout request\n+    const royalty = new Royalty({\n+      authorId: req.user._id,\n+      amount,\n+      paymentMethod,\n+      status: 'Pending'\n+    });\n+\n+    await royalty.save();\n+\n+    // Update royalty balances\n+    author.outstandingRoyalty -= amount;\n+    author.royaltyReceived += amount;\n+    await author.save();\n+\n+    res.status(201).json({\n+      message: 'Payout request submitted',\n+      royalty\n+    });\n+  } catch (error) {\n+    res.status(500).json({ \n+      message: 'Error creating payout request',\n+      error: error.message \n+    });\n+  }\n+};\n+\n+exports.refreshToken = async (req, res) => {\n+  try {\n+    const refreshToken = req.cookies.refreshToken;\n+    if (!refreshToken) return res.sendStatus(401);\n+\n+    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\n+    const user = await User.findById(decoded.id);\n+    \n+    if (!user) return res.sendStatus(403);\n+    \n+    const accessToken = jwt.sign(\n+      { id: user._id }, \n+      process.env.JWT_SECRET, \n+      { expiresIn: '15m' }\n+    );\n+\n+    res.json({ token: accessToken });\n+  } catch (error) {\n+    res.status(500).json({ message: 'Token refresh failed' });\n+  }\n+};\n+\n+module.exports = {\n+  register,\n+  login,\n+  forgotPassword,\n+  resetPassword,\n+  getProfile,\n+  updateProfile,\n+  googleLogin,\n+  requestPayout,\n+  refreshToken: exports.refreshToken\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1741454159899,
            "name": "Commit-0",
            "content": "const jwt = require('jsonwebtoken');\nconst User = require('../models/User');\nconst { \n  sendEmail, \n  getWelcomeEmailTemplate, \n  getLoginNotificationTemplate,\n  getPasswordResetTemplate \n} = require('../config/email');\nconst { OAuth2Client } = require('google-auth-library');\nconst Royalty = require('../models/Royalty');\nconst { sendSMS } = require('../services/notificationService');\n\nconst client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);\n\nconst generateToken = (userId) => {\n  return jwt.sign({ userId }, process.env.JWT_SECRET, {\n    expiresIn: process.env.JWT_EXPIRES_IN || '30d'\n  });\n};\n\nconst register = async (req, res) => {\n  try {\n    const { email, name } = req.body;\n    \n    // Check if user already exists\n    const existingUser = await User.findOne({ email });\n    if (existingUser) {\n      return res.status(400).json({ message: 'User already exists' });\n    }\n\n    // Create new user\n    const user = new User(req.body);\n    await user.save();\n\n    // Generate token\n    const token = generateToken(user._id);\n\n    // Send welcome email\n    const emailTemplate = getWelcomeEmailTemplate(name);\n    await sendEmail({\n      to: email,\n      subject: emailTemplate.subject,\n      html: emailTemplate.html\n    });\n\n    // Send SMS notification\n    await sendSMS(user.phone, `Welcome ${user.name}! Your author account is ready.`);\n\n    // Return user data without password\n    const userData = user.toObject();\n    delete userData.password;\n\n    res.status(201).json({\n      message: 'User registered successfully',\n      user: userData,\n      token\n    });\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error registering user',\n      error: error.message \n    });\n  }\n};\n\nconst login = async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    // Find user by email\n    const user = await User.findOne({ email }).select('+password');\n\n    if (!user) {\n      return res.status(401).json({ message: 'Invalid credentials' });\n    }\n\n    // Check password\n    const isMatch = await user.comparePassword(password);\n    if (!isMatch) {\n      return res.status(401).json({ message: 'Invalid credentials' });\n    }\n\n    // Generate token\n    const token = generateToken(user._id);\n\n    // Send login notification email\n    const emailTemplate = getLoginNotificationTemplate(user.name);\n    await sendEmail({\n      to: email,\n      subject: emailTemplate.subject,\n      html: emailTemplate.html\n    });\n\n    // Return user data without password\n    const userData = user.toObject();\n    delete userData.password;\n\n    res.json({\n      message: 'Login successful',\n      user: userData,\n      token\n    });\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error logging in',\n      error: error.message \n    });\n  }\n};\n\nconst forgotPassword = async (req, res) => {\n  try {\n    const { email } = req.body;\n\n    // Find user\n    const user = await User.findOne({ email });\n    if (!user) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n\n    // Generate password reset token\n    const resetToken = jwt.sign(\n      { userId: user._id },\n      process.env.JWT_SECRET,\n      { expiresIn: '1h' }\n    );\n\n    // Create password reset link\n    const resetLink = `${process.env.CLIENT_URL}/reset-password?token=${resetToken}`;\n\n    // Send password reset email\n    const emailTemplate = getPasswordResetTemplate(user.name, resetLink);\n    await sendEmail({\n      to: email,\n      subject: emailTemplate.subject,\n      html: emailTemplate.html\n    });\n\n    res.json({ \n      message: 'Password reset instructions sent to your email' \n    });\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error processing forgot password request',\n      error: error.message \n    });\n  }\n};\n\nconst resetPassword = async (req, res) => {\n  try {\n    const { token, newPassword } = req.body;\n    \n    // Verify token and decode payload\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    \n    // Find user by decoded ID\n    const user = await User.findById(decoded.userId);\n    if (!user) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n\n    // Update password and save\n    user.password = newPassword;\n    await user.save();\n    \n    res.json({ message: 'Password reset successful' });\n  } catch (error) {\n    // Handle specific JWT errors\n    if (error instanceof jwt.JsonWebTokenError || error instanceof jwt.TokenExpiredError) {\n      return res.status(401).json({ \n        message: 'Invalid or expired token',\n        error: error.message \n      });\n    }\n    \n    // Handle other errors\n    res.status(500).json({ \n      message: 'Error resetting password',\n      error: error.message \n    });\n  }\n};\n\nconst getProfile = async (req, res) => {\n  try {\n    const user = await User.findById(req.user._id).select('-password');\n    if (!user) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n    res.json(user);\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error fetching profile',\n      error: error.message \n    });\n  }\n};\n\nconst updateProfile = async (req, res) => {\n  try {\n    let updates = req.body;\n    \n    // Handle file upload\n    if (req.file) {\n      updates.profilePhoto = `${process.env.BASE_URL}/profile-photos/${req.file.filename}`;\n    }\n\n    // Update allowed updates\n    const allowedUpdates = [\n      'name', 'phoneNumber', 'address', 'bankAccount', \n      'about', 'profilePhoto', 'governmentId', 'authorStats'\n    ];\n    \n    const filteredUpdates = Object.keys(updates)\n      .filter(key => allowedUpdates.includes(key))\n      .reduce((obj, key) => {\n        // Handle nested objects\n        if (key === 'authorStats') {\n          obj[key] = updates[key];\n        } else {\n          obj[key] = updates[key];\n        }\n        return obj;\n      }, {});\n\n    // If KYC details are updated, reset status to pending\n    if (filteredUpdates.governmentId || filteredUpdates.bankAccount) {\n      filteredUpdates.kycStatus = 'pending';\n    }\n\n    const user = await User.findByIdAndUpdate(\n      req.user._id,\n      { $set: filteredUpdates },\n      { new: true, runValidators: true }\n    ).select('-password -governmentId');\n\n    res.json({\n      message: 'Profile updated successfully',\n      user\n    });\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error updating profile',\n      error: error.message \n    });\n  }\n};\n\nconst googleLogin = async (req, res) => {\n  try {\n    const { token } = req.body;\n    \n    // Verify Google token\n    const ticket = await client.verifyIdToken({\n      idToken: token,\n      audience: process.env.GOOGLE_CLIENT_ID\n    });\n    \n    const payload = ticket.getPayload();\n    \n    // Check if user already exists\n    let user = await User.findOne({ \n      $or: [{ googleId: payload.sub }, { email: payload.email }]\n    });\n\n    if (!user) {\n      // Create new user\n      user = new User({\n        name: payload.name,\n        email: payload.email,\n        googleId: payload.sub,\n        authMethod: 'google',\n        verified: true,\n        profile: {\n          photo: payload.picture\n        }\n      });\n      await user.save();\n    }\n\n    // Generate JWT\n    const jwtToken = generateToken(user._id);\n    \n    // Return user data\n    const userData = user.toObject();\n    delete userData.password;\n\n    res.json({\n      message: 'Google login successful',\n      user: userData,\n      token: jwtToken\n    });\n\n  } catch (error) {\n    res.status(401).json({\n      message: 'Google authentication failed',\n      error: error.message\n    });\n  }\n};\n\nconst requestPayout = async (req, res) => {\n  try {\n    const { amount, paymentMethod } = req.body;\n    \n    // Check available royalty balance\n    const author = await User.findById(req.user._id);\n    if (author.outstandingRoyalty < amount) {\n      return res.status(400).json({ \n        message: 'Insufficient royalty balance' \n      });\n    }\n\n    // Create payout request\n    const royalty = new Royalty({\n      authorId: req.user._id,\n      amount,\n      paymentMethod,\n      status: 'Pending'\n    });\n\n    await royalty.save();\n\n    // Update royalty balances\n    author.outstandingRoyalty -= amount;\n    author.royaltyReceived += amount;\n    await author.save();\n\n    res.status(201).json({\n      message: 'Payout request submitted',\n      royalty\n    });\n  } catch (error) {\n    res.status(500).json({ \n      message: 'Error creating payout request',\n      error: error.message \n    });\n  }\n};\n\nexports.refreshToken = async (req, res) => {\n  try {\n    const refreshToken = req.cookies.refreshToken;\n    if (!refreshToken) return res.sendStatus(401);\n\n    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\n    const user = await User.findById(decoded.id);\n    \n    if (!user) return res.sendStatus(403);\n    \n    const accessToken = jwt.sign(\n      { id: user._id }, \n      process.env.JWT_SECRET, \n      { expiresIn: '15m' }\n    );\n\n    res.json({ token: accessToken });\n  } catch (error) {\n    res.status(500).json({ message: 'Token refresh failed' });\n  }\n};\n\nmodule.exports = {\n  register,\n  login,\n  forgotPassword,\n  resetPassword,\n  getProfile,\n  updateProfile,\n  googleLogin,\n  requestPayout,\n  refreshToken: exports.refreshToken\n};"
        }
    ]
}